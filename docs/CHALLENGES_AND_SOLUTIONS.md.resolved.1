[← 메인으로 돌아가기](../README.md)

# 개발 중 직면한 어려움과 해결 과정 (Challenges & Solutions)

프로젝트 개발 과정에서 마주친 기술적 난관들과 이를 극복하기 위해 적용한 해결책들을 정리했습니다.

## 1. 비동기 데이터와 UI 동기화 문제 (Chat UX)

**문제점 (Challenge):**
사용자가 메시지를 보낸 후, 서버로부터 AI의 응답이 올 때까지의 지연 시간(Latency) 동안 화면이 정지된 것처럼 보이는 문제가 있었습니다. 또한, 네트워크 상태가 불안정할 때 요청이 실패하면 사용자는 메시지가 보내졌는지 알 수 없어 혼란스러워했습니다.

**해결책 (Solution):**

- **낙관적 업데이트 (Optimistic Update)** 적용: 서버 응답을 기다리지 않고, [sendMessage](file:///c:/Users/minse/OneDrive/%EB%AC%B8%EC%84%9C/GitHub/GangNaengBot-FE/src/store/useChatStore.ts#239-365) 호출 즉시 로컬 상태(`messages`)에 사용자의 메시지를 추가하여 UI 반응성을 높였습니다.
- **상태 롤백**: `try-catch` 블록을 활용하여 API 호출 실패 시, 임시로 추가했던 메시지를 `slice`로 제거하고 에러 메시지를 표시하여 데이터 무결성을 유지했습니다.
- **재시도 메커니즘**: 단순 실패 처리가 아닌, 백그라운드 재시도(Retry) 로직을 `useChatStore`에 구현하여 일시적인 네트워크 오류를 사용자가 인지하지 못하게 자동으로 복구했습니다.

## 2. 복잡한 계층형 폼 데이터 관리

**문제점 (Challenge):**
프로필 수정 페이지에서 '단과대학 → 학부 → 전공'으로 이어지는 계층적 데이터 구조를 처리해야 했습니다. 상위 항목(예: 단과대학)이 변경되었을 때 하위 항목(예: 학부, 전공)이 초기화되지 않거나, 잘못된 조합이 선택된 채로 남는 버그가 발생하기 쉬웠습니다.

**해결책 (Solution):**

- **의존성 기반 상태 초기화**: [handleChange](file:///c:/Users/minse/OneDrive/%EB%AC%B8%EC%84%9C/GitHub/GangNaengBot-FE/src/components/chat/ProfileModal.tsx#117-140) 함수 내에서 특정 필드 변경 시 연관된 하위 필드들을 명시적으로 빈 문자열(`""`)로 초기화하는 로직을 통합했습니다.
- **동적 옵션 필터링**: `DEPARTMENTS`, `MAJORS` 상수 객체를 활용하여, 현재 선택된 상위 키값에 따라 하위 드롭다운의 `options`를 실시간으로 계산하여 렌더링하도록 구현했습니다.

## 3. 다크 모드 깜빡임 (FOUC)

**문제점 (Challenge):**
페이지 새로고침 시, 자바스크립트가 로드되고 테마 상태(`zustand`)를 읽어오기 전까지 아주 짧은 순간 흰색(기본) 배경이 보였다가 다크 모드로 변하는 '깜빡임(Flash of Unstyled Content)' 현상이 발생했습니다.

**해결책 (Solution):**

- **로컬 스토리지 동기화**: `zustand`의 `persist` 미들웨어를 사용하여 테마 설정을 `localStorage`에 저장했습니다.
- **초기화 로직 최적화**: 앱 진입 시점([App.tsx](file:///c:/Users/minse/OneDrive/%EB%AC%B8%EC%84%9C/GitHub/GangNaengBot-FE/src/App.tsx)의 `useEffect`) 뿐만 아니라, [initializeTheme](file:///c:/Users/minse/OneDrive/%EB%AC%B8%EC%84%9C/GitHub/GangNaengBot-FE/src/store/useSettingsStore.ts#59-76) 함수를 통해 스토어 초기화 시점에 즉시 `document.documentElement`에 `dark` 클래스를 주입하여 렌더링 이전에 테마가 적용되도록 했습니다.

## 4. 인증 토큰 만료 처리

**문제점 (Challenge):**
`access_token`이 만료되었을 때, 사용자가 이를 인지하지 못하고 계속 API 요청을 보내면 401 에러가 발생하고 앱이 동작하지 않는 것처럼 보이는 문제가 있었습니다.

**해결책 (Solution):**

- **Axios Interceptor 중앙화**: 개별 컴포넌트에서 에러를 처리하는 대신, `apiClient`의 응답 인터셉터에서 401 에러를 전역적으로 감지하도록 구현했습니다.
- **자동 로그아웃 흐름**: 401 발생 시 즉시 로컬 스토리지의 토큰을 삭제하고 `/login`으로 강제 이동시켜, 사용자가 자연스럽게 재로그인할 수 있는 흐름(Flow)을 만들었습니다.
